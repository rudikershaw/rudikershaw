<!DOCTYPE html>
<html lang="en" dir="ltr" xmlns:th="http://www.thymeleaf.org">
	<head>
        <link th:replace="fragments/article/head :: head">
    </head>
	<body>
		<header th:replace="index :: header"></header>
		<article>
			<div class="text-container">
				<p class="date">18/05/2020</p>
				<p class="views"><span th:text="${article.views}">1</span> views</p>
			</div>

			<section>
				<h1 th:text="${article.name}">On Being Stuck</h1>
				<hr />
				<img class="coverimg" src="/images/on-being-stuck-banner.jpg" alt="A brown orange teddy bear stuck in a tree" />
				<br />
				<p>Every programmer gets stuck. You might be working on a particularly tricky bug, or in a domain you are unfamiliar with, and all of a
					sudden you are hit by that awful feeling. A exasperating feeling that can be summed up in the phrase "I have no idea where to go from here".
					Being able to break out of that rut is an important skill in itself.</p>
				<br />
				<p>So what should a programmer do when they get stuck? We'll get to that. But first, what <em>precisely</em> is <b>being stuck</b>?</p>
			</section>

			<section>
				<h2>What Is <i>Being Stuck</i>?</h2>
				<p>First things first, what do the dictionaries say? The most appropriate definition I can find for being stuck is from the
					<cite><a href="https://www.thefreedictionary.com/being+stuck">Cambridge Dictionary</a></cite> and it says:</p>
				<blockquote>
					<span class="green">"</span>not able to continue reading, answering questions, etc. because something is too difficult<span class="green">"</span>
				</blockquote>
				<p>Not bad, but we can do better. Saying something is too difficult is unhelpful and imprecise. It is tempting to just take that off the end of the
					definition. But if you're not able to continue because you're playing computer games then you're not stuck, you're procrastinating. So what
					differentiates someone who is procrastinating from someone who is genuinely stuck? Knowing the next step.</p>
				<br />
				<p>We're almost there with a precise enough definition, but something is missing. If I'm working and suddenly realise I don't know how to proceed, am I
					immediately stuck? It's tempting to say yes. But if I realise what to do two seconds afterward, was I stuck in hind-sight? No. Being stuck for two
					seconds isn't really being stuck. Now we have a precise definition for our purposes here.</p>
				<blockquote>
					<span class="green">"</span>Being stuck is not being able to continue with a given task, for a significant time, because we cannot work out how to proceed.<span class="green">"</span>
					<footer>- Me, <cite>just now</cite></footer>
				</blockquote>
			</section>

			<section>
				<h2>Time Management</h2>
				<p>Being stuck is like alcoholism<sup>(it isn't)</sup>. To fix it you must first recognise you have a problem. The sooner we can recognise that we're
					stuck or floundering the quicker we can get back on track. How can we ensure we're aware as soon as we can be? By using some common time management
					techniques.</p>
				<br />
				<ul class="dark">
					<li>Task estimates.</li>
					<li>Time trackers.</li>
					<li>Timeboxing.</li>
					<li>Pomodoro technique.</li>
				</ul>
				<h3>Task Estimates</h3>
				<p>If you look back to our definition, you'll noticed we used the ambiguous phrase <q>"for a significant time"</q>. That's because what we consider
					<i>significant</i> depends on our context. If you're looking for a proof that <var>P</var> â‰  <var>NP</var> then not making progress for a couple
					of days (or weeks or years) doesn't mean you're stuck, in fact it is expected. If on the other hand you're fixing a simple
					<abbr title="User Interface">UI</abbr> bug on a web application then you are well, truly, and extremely stuck.</p>
				<br/>
				<p>You need to know how long the problem is expected to take. Which is why you should always have an estimate of the time it will take to complete
					your current task, even if you make that estimate yourself.</p>
				<h3>Time Trackers</h3>
				<p>Knowing how long you can expect a task to take is great, but if you don't know how long you've been working on it how will you know that you're
					struggling? Tracking your time can be as simple as making a note of the time you started, or using an actual timer that runs while you work.</p>
				<h3>Timeboxing</h3>
				<p>Timeboxing simply means setting a time you'll be done by and sticking to it. You can use your original estimate, or some other upper limit. As
					this final time grows closer you will be more aware of any impediments to reaching your goal. You can also use it once you realise you are stuck,
					so that you can say <q>"if working this way doesn't bear fruit in the next hour, I need to rethink my approach"</q>.</p>
				<h3>Pomodoro Technique</h3>
				<p>The <a href="https://en.wikipedia.org/wiki/Pomodoro_Technique">Pomodoro technique</a> is a time management technique that combines elements of the
					others above. It can be approximately summed up as;</p>
				<br />
				<ol class="dark">
					<li>Set a timer for <var>x</var> minutes.</li>
					<li>Work exclusively on your task.</li>
					<li>When the timer goes off tally a mark on a piece of paper.</li>
					<li>If you have less than four marks take a 5 minute break and goto 1.</li>
					<li>After 4 marks take a longer break and start again.</li>
				</ol>
				<br />
				<p>As well as being a productive way to work, the timer gives you an easy way to be sure when you're stuck. If you're having trouble when it goes off
					then you take your break and start again. If you're still stuck the next time the timer goes off, then you know you need to try something different.</p>
			</section>

			<section>
				<h2>How To Proceed</h2>
				<p>So you're stuck. Probably the most important part of our definition of being stuck is that <q>"we cannot work out how to proceed"</q>. Not knowing how
					to move forward is fundamentally a lack of information. That leads us neatly to what we have to do now: information gathering.</p>
				<br />
				<p>Most software development tasks follow a pretty standard story. You can get stuck in any part of this story, or you can be stuck further along in the story because
					of misunderstandings brought forward from an earlier step. It's important, when stuck, to make sure you have the information you need from each step.</p>
				<br />
				<ul class="dark">
					<li>Requirements.</li>
					<li>Issue reproduction.</li>
					<li>Identifying the source.</li>
					<li>Doing something about it.</li>
				</ul>
				<br />
				<p>Let's go through these, one at a time, and discuss the kinds of problems we can fall into. And more importantly, what we should be doing about them. If
					you're stuck at any stage it's best to go through all of these. If only to double check that you understand each correctly.</p>
				<h3>Requirements</h3>
				<p>Getting stuck here is easy and common. When programmers think about tough problems they think about choosing the right search algorithm for
					unusual data structures, identifying race conditions in heavily asynchronous systems, tracking down memory leaks, or other such technical tasks. But
					in my experience that is not where we spend most of our time stuck.</p>
				<br />
				<p>First things first, make sure you understand the requirements. Not just at a cursory glance either. A bad assumption here can lead you down the wrong
					path and straight to a dead end. That means understanding how the system operates <em>now</em>, and how we intend it to work <em>after</em> your task
					is complete.</p>
				<br />
				<p>Software developers have a tendency to avoid communicating with other people. <em>Don't avoid talking to people</em>. Make a list of <em>any</em>
					questions, or <em>any</em> assumptions, and go check with an appropriate stake-holder. That could be the project owner, the technical lead, or the
					customer directly. Once you have your answers, update your task to include the new details so you're not the only one to benefit from the clearer
					requirements.</p>
				<h3>Issue Reproduction</h3>
				<p>To understand an issue you need to be able to reproduce the non-ideal situation. Especially if that situation is a bug. Getting stuck here is more simple.
					If you can't reproduce the problem, go ask the person who had it. It might be that something specific about their situation hasn't been mentioned.</p>
				<br />
				<p>If there <em>is</em> something very specific that is required to reproduce their issue, and you have identified what it is, then congratulations. You now have
					a valuable clue.</p>
				<h3>Identifying The Source</h3>
				<p>Now it is time to work out where in the code we have to make some changes. For bugs this is about finding the root cause. For new features or improvements this
					is a question of understanding the architecture as a whole, and finding the cleanest place to refactor, add, or delete logic. If you're stuck here it is because
					your search has come to a dead end, or you don't even know what you're looking for. What should we do about this?</p>
				<br />
				<ul class="dark">
					<li>Find an entry point.</li>
					<li>Do a human binary search.</li>
					<li><em>READ THE CODE</em>.</li>
					<li>Refactor.</li>
					<li>Experiment with changes.</li>
					<li>RTFM.</li>
				</ul>
				<h4>Find an Entry Point</h4>
				<p>If your project has strong naming conventions, and you have good domain knowledge, you may be able to just search for the name of a file you think is affected.
					But in most cases you will need somewhere to start your search. Usually that place is where we interact with your application. This might be a web service, a user
					interface, or in the console.</p>
				<br />
				<p>For web applications this might be a controller, <abbr title="Representational state transfer">REST</abbr> end-point, or an <abbr title="HyperText Markup Language">HTML</abbr>
					file, that maps to the <abbr title="Uniform Resource Locator">URL</abbr> we are visiting when the problem occurs. For scheduled jobs this might be the logs, or an applications
				    command line interface. Either way, identifying the location of code responsible for the interface is simpler. Simply search in your project for parts of the
					<abbr title="Uniform Resource Locator">URL</abbr>, command, log messages, etc that identify that interface. The searching capabilities of your favorite tools are your
					friend here. Once we've found this code, we have a starting point.</p>
				<br />
			</section>

		</article>
		<hr />

        <div class="article-footer" th:replace="fragments/article/footer :: article-footer"></div>

		<div class="text-container"><div id="disqus_thread"></div></div>
		<script type="text/javascript">
			/* * * Configure Disqus Variables * * */
			var disqus_shortname = 'codenerd';
			var disqus_identifier = '1 - On Being Stuck';
			var disqus_title = 'On Being Stuck';

			/* * * Declare disqus display script * * */
			(function() {
				var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
				(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
			})();
		</script>
		<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

	</body>
</html>
